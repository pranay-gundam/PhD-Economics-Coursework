%--------------------
% Packages
% -------------------
\documentclass[11pt,english]{article}
\usepackage{amsfonts}
\usepackage[left=2.5cm,top=2cm,right=2.5cm,bottom=3cm,bindingoffset=0cm]{geometry}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{tikz}
\usetikzlibrary{calc}
\usetikzlibrary{decorations.pathreplacing,calligraphy}
\usepackage{fancyhdr}
%\usepackage{currfile}
\usepackage{nicefrac}
\usepackage{cite}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{longtable}
\usepackage{rotating}
\usepackage{lscape}
\usepackage{booktabs}
\usepackage{float}
\usepackage{placeins}
\usepackage{setspace}
\usepackage[font=itshape]{quoting}
\onehalfspacing
\usepackage{mathrsfs}
\usepackage{tcolorbox}
\usepackage{xcolor}
\usepackage{subcaption}
\usepackage{float}
\usepackage[multiple]{footmisc}
\usepackage[T1]{fontenc}
\usepackage[sc]{mathpazo}
\usepackage{listings}
\usepackage{longtable}
\definecolor{cmured}{RGB}{175,30,45}
\definecolor{macroblue}{RGB}{56,108,176}
\usepackage[format=plain,
            labelfont=bf,
            textfont=]{caption}
\usepackage[colorlinks=true,citecolor=macroblue,linkcolor=macroblue,urlcolor=macroblue]{hyperref}
\usepackage{varioref}
\usepackage{chngcntr}

\definecolor{darkgreen}{RGB}{30,175,88}
\definecolor{darkblue}{RGB}{30,118,175}
\definecolor{maroon}{rgb}{0.66,0,0}
\definecolor{darkgreen}{rgb}{0,0.69,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{juliastyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{darkgreen},
    keywordstyle=\color{darkblue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{maroon},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                                 
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=juliastyle}

%Counters
\newtheorem{theorem}{Theorem}[section] 
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{assumption}{Assumption}
\newtheorem{axiom}{Axiom}
\newtheorem{case}{Case}
\newtheorem{claim}{Claim}
\newtheorem{condition}{Condition}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\newtheorem{notation}{Notation}
\newtheorem{remark}{Remark}



\hypersetup{ 	
pdfsubject = {},
pdftitle = {Job Search Models and Code},
pdfauthor = {Pranay Gundam},
linkcolor= macroblue
}


\title{\textbf{Job Search Models and Code}}
\author{Pranay Gundam}

%-----------------------
% Begin document
%-----------------------
\begin{document}

\maketitle

\tableofcontents

\section{The Basic Job Search Question}

Consider a worker who lives infinitely and lives their life in discrete time periods $t=0,1,\ldots$. They posses some temporal discount factor $0 < \beta < 1$ and also have a increasing concave utility function $u(\cdot)$. At each time period $t$, this worker can either be employed or unemployed. If they are employed then they will have been given some job offer in the past they they have accepted which pays them a wage $w$. If they are unemployed, in the beginning of the time period they draw an employment offer $w$ from some distribution $F(\cdot)$ and then have the choice to accept the job for life such that they earn that wage $w$ for the rest of their lives or recieve a unemployment benefit $b$ in that period to remain unemployed in the beginning of the next period.\\

\noindent This is the basic setup of the problem (we will discuss other extensions of the problem as well later) from which point there are a few questions that are typically asked such as: at any point in time, if the worker is unemployed, what is the smallest wage from a job offer they would accept. This involves solving for the opportunity cost of taking the offer which we can set up as a dynamic programming problem. \\

\noindent Specifically we can say that when the unemployed worker is faced with a job wage offer $w$ they are to maximize the value function $$v(w) = \max_{accept, reject}\left\{\frac{w}{1-\beta}, b + \beta\int v(w') \,dF(w')\right\}.$$

\noindent The first term in the maximization represents the closed form of the geometric series of all the future income the worker will recieve as a result of taking the job offer and the second term represents getting an unemployment payment in the current period and the expected value of the value function itself (which we get by changing the integral to be with respect to the probability distribution of the wage draws); this is the term that represents the opportunity cost.\\

\noindent For the basic setup, we are given the discount factor, unemployment benefit, and probability distribution for the wage draws so the only difficult concept to consider now is the recursive formulation of the value function. We can't solve for an explicit form since the value function is itself in part defined by a integral over it. One of the most common ways to proceed now is to use value function iteration, an iterative algorithm that starts with a guess for what the shape of our value function looks like and continue to refine.

\section{Value Function Iteration (VFI)}

Value function iteration is one of the analytical processes people use to learn the shape of certain functions and is used a lot in Macroeconomics. The benefit of value function iteration is that it is stable, meaning that we know it will eventually converge to the true solution. It is, however, also very slow and achieving the granularity that we often desire requires us to keep track of a very large statespace especially as we increase the dimensionality of the state we want to track.\\

\noindent The algorithm will look slightly difference based on the notation and problem setup but the general idea is the same. For the problem defined above we can do VFI as such: determine the statespace $S$ and initialize a $v_0(s)$ for all $s\in S$. Then determine $v_1, v_2, \ldots$ with the update rule: $$v_k(s) = \max_{accept, reject}\left\{,\right\}$$

\noindent One additional key point is the idea of a policy function. This goes hand-in-hand with the value function in that instead of taking a max over the two terms we specified above we take an argmax to identify the optimal action of the agent given a state.
\subsection{Stability of VFI}

Let $v_k$ be our guess of value function at the $k-$th iteration of VFI. We can say that VFI is stable iff $$\lim_{k\to \infty}v_k = v^*$$ where $v^*$ is the true value function.



\subsection{VFI Pseudo-code}

\subsection{Speeding up VFI}

\section{Common Extenstions of the Job Search Question}



\section{Code Documentation}

\section{What more to add?}



\end{document}